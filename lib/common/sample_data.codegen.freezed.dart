// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sample_data.codegen.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SampleData2<T1, T2> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;

  /// Create a copy of SampleData2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleData2CopyWith<T1, T2, SampleData2<T1, T2>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleData2CopyWith<T1, T2, $Res> {
  factory $SampleData2CopyWith(
          SampleData2<T1, T2> value, $Res Function(SampleData2<T1, T2>) then) =
      _$SampleData2CopyWithImpl<T1, T2, $Res, SampleData2<T1, T2>>;
  @useResult
  $Res call({T1 t1, T2 t2});
}

/// @nodoc
class _$SampleData2CopyWithImpl<T1, T2, $Res, $Val extends SampleData2<T1, T2>>
    implements $SampleData2CopyWith<T1, T2, $Res> {
  _$SampleData2CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleData2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
  }) {
    return _then(_value.copyWith(
      t1: freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      t2: freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleData2ImplCopyWith<T1, T2, $Res>
    implements $SampleData2CopyWith<T1, T2, $Res> {
  factory _$$SampleData2ImplCopyWith(_$SampleData2Impl<T1, T2> value,
          $Res Function(_$SampleData2Impl<T1, T2>) then) =
      __$$SampleData2ImplCopyWithImpl<T1, T2, $Res>;
  @override
  @useResult
  $Res call({T1 t1, T2 t2});
}

/// @nodoc
class __$$SampleData2ImplCopyWithImpl<T1, T2, $Res>
    extends _$SampleData2CopyWithImpl<T1, T2, $Res, _$SampleData2Impl<T1, T2>>
    implements _$$SampleData2ImplCopyWith<T1, T2, $Res> {
  __$$SampleData2ImplCopyWithImpl(_$SampleData2Impl<T1, T2> _value,
      $Res Function(_$SampleData2Impl<T1, T2>) _then)
      : super(_value, _then);

  /// Create a copy of SampleData2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
  }) {
    return _then(_$SampleData2Impl<T1, T2>(
      freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
    ));
  }
}

/// @nodoc

class _$SampleData2Impl<T1, T2> implements _SampleData2<T1, T2> {
  const _$SampleData2Impl(this.t1, this.t2);

  @override
  final T1 t1;
  @override
  final T2 t2;

  @override
  String toString() {
    return 'SampleData2<$T1, $T2>(t1: $t1, t2: $t2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData2Impl<T1, T2> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2));

  /// Create a copy of SampleData2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleData2ImplCopyWith<T1, T2, _$SampleData2Impl<T1, T2>> get copyWith =>
      __$$SampleData2ImplCopyWithImpl<T1, T2, _$SampleData2Impl<T1, T2>>(
          this, _$identity);
}

abstract class _SampleData2<T1, T2> implements SampleData2<T1, T2> {
  const factory _SampleData2(final T1 t1, final T2 t2) =
      _$SampleData2Impl<T1, T2>;

  @override
  T1 get t1;
  @override
  T2 get t2;

  /// Create a copy of SampleData2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleData2ImplCopyWith<T1, T2, _$SampleData2Impl<T1, T2>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SampleData3<T1, T2, T3> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;

  /// Create a copy of SampleData3
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleData3CopyWith<T1, T2, T3, SampleData3<T1, T2, T3>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleData3CopyWith<T1, T2, T3, $Res> {
  factory $SampleData3CopyWith(SampleData3<T1, T2, T3> value,
          $Res Function(SampleData3<T1, T2, T3>) then) =
      _$SampleData3CopyWithImpl<T1, T2, T3, $Res, SampleData3<T1, T2, T3>>;
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3});
}

/// @nodoc
class _$SampleData3CopyWithImpl<T1, T2, T3, $Res,
        $Val extends SampleData3<T1, T2, T3>>
    implements $SampleData3CopyWith<T1, T2, T3, $Res> {
  _$SampleData3CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleData3
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
  }) {
    return _then(_value.copyWith(
      t1: freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      t2: freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      t3: freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleData3ImplCopyWith<T1, T2, T3, $Res>
    implements $SampleData3CopyWith<T1, T2, T3, $Res> {
  factory _$$SampleData3ImplCopyWith(_$SampleData3Impl<T1, T2, T3> value,
          $Res Function(_$SampleData3Impl<T1, T2, T3>) then) =
      __$$SampleData3ImplCopyWithImpl<T1, T2, T3, $Res>;
  @override
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3});
}

/// @nodoc
class __$$SampleData3ImplCopyWithImpl<T1, T2, T3, $Res>
    extends _$SampleData3CopyWithImpl<T1, T2, T3, $Res,
        _$SampleData3Impl<T1, T2, T3>>
    implements _$$SampleData3ImplCopyWith<T1, T2, T3, $Res> {
  __$$SampleData3ImplCopyWithImpl(_$SampleData3Impl<T1, T2, T3> _value,
      $Res Function(_$SampleData3Impl<T1, T2, T3>) _then)
      : super(_value, _then);

  /// Create a copy of SampleData3
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
  }) {
    return _then(_$SampleData3Impl<T1, T2, T3>(
      freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
    ));
  }
}

/// @nodoc

class _$SampleData3Impl<T1, T2, T3> implements _SampleData3<T1, T2, T3> {
  const _$SampleData3Impl(this.t1, this.t2, this.t3);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;

  @override
  String toString() {
    return 'SampleData3<$T1, $T2, $T3>(t1: $t1, t2: $t2, t3: $t3)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData3Impl<T1, T2, T3> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3));

  /// Create a copy of SampleData3
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleData3ImplCopyWith<T1, T2, T3, _$SampleData3Impl<T1, T2, T3>>
      get copyWith => __$$SampleData3ImplCopyWithImpl<T1, T2, T3,
          _$SampleData3Impl<T1, T2, T3>>(this, _$identity);
}

abstract class _SampleData3<T1, T2, T3> implements SampleData3<T1, T2, T3> {
  const factory _SampleData3(final T1 t1, final T2 t2, final T3 t3) =
      _$SampleData3Impl<T1, T2, T3>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;

  /// Create a copy of SampleData3
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleData3ImplCopyWith<T1, T2, T3, _$SampleData3Impl<T1, T2, T3>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SampleData4<T1, T2, T3, T4> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;

  /// Create a copy of SampleData4
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleData4CopyWith<T1, T2, T3, T4, SampleData4<T1, T2, T3, T4>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleData4CopyWith<T1, T2, T3, T4, $Res> {
  factory $SampleData4CopyWith(SampleData4<T1, T2, T3, T4> value,
          $Res Function(SampleData4<T1, T2, T3, T4>) then) =
      _$SampleData4CopyWithImpl<T1, T2, T3, T4, $Res,
          SampleData4<T1, T2, T3, T4>>;
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4});
}

/// @nodoc
class _$SampleData4CopyWithImpl<T1, T2, T3, T4, $Res,
        $Val extends SampleData4<T1, T2, T3, T4>>
    implements $SampleData4CopyWith<T1, T2, T3, T4, $Res> {
  _$SampleData4CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleData4
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
  }) {
    return _then(_value.copyWith(
      t1: freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      t2: freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      t3: freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      t4: freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleData4ImplCopyWith<T1, T2, T3, T4, $Res>
    implements $SampleData4CopyWith<T1, T2, T3, T4, $Res> {
  factory _$$SampleData4ImplCopyWith(_$SampleData4Impl<T1, T2, T3, T4> value,
          $Res Function(_$SampleData4Impl<T1, T2, T3, T4>) then) =
      __$$SampleData4ImplCopyWithImpl<T1, T2, T3, T4, $Res>;
  @override
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4});
}

/// @nodoc
class __$$SampleData4ImplCopyWithImpl<T1, T2, T3, T4, $Res>
    extends _$SampleData4CopyWithImpl<T1, T2, T3, T4, $Res,
        _$SampleData4Impl<T1, T2, T3, T4>>
    implements _$$SampleData4ImplCopyWith<T1, T2, T3, T4, $Res> {
  __$$SampleData4ImplCopyWithImpl(_$SampleData4Impl<T1, T2, T3, T4> _value,
      $Res Function(_$SampleData4Impl<T1, T2, T3, T4>) _then)
      : super(_value, _then);

  /// Create a copy of SampleData4
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
  }) {
    return _then(_$SampleData4Impl<T1, T2, T3, T4>(
      freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
    ));
  }
}

/// @nodoc

class _$SampleData4Impl<T1, T2, T3, T4>
    implements _SampleData4<T1, T2, T3, T4> {
  const _$SampleData4Impl(this.t1, this.t2, this.t3, this.t4);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;

  @override
  String toString() {
    return 'SampleData4<$T1, $T2, $T3, $T4>(t1: $t1, t2: $t2, t3: $t3, t4: $t4)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData4Impl<T1, T2, T3, T4> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4));

  /// Create a copy of SampleData4
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleData4ImplCopyWith<T1, T2, T3, T4, _$SampleData4Impl<T1, T2, T3, T4>>
      get copyWith => __$$SampleData4ImplCopyWithImpl<T1, T2, T3, T4,
          _$SampleData4Impl<T1, T2, T3, T4>>(this, _$identity);
}

abstract class _SampleData4<T1, T2, T3, T4>
    implements SampleData4<T1, T2, T3, T4> {
  const factory _SampleData4(
          final T1 t1, final T2 t2, final T3 t3, final T4 t4) =
      _$SampleData4Impl<T1, T2, T3, T4>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;

  /// Create a copy of SampleData4
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleData4ImplCopyWith<T1, T2, T3, T4, _$SampleData4Impl<T1, T2, T3, T4>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SampleData5<T1, T2, T3, T4, T5> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;
  T5 get t5 => throw _privateConstructorUsedError;

  /// Create a copy of SampleData5
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleData5CopyWith<T1, T2, T3, T4, T5, SampleData5<T1, T2, T3, T4, T5>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleData5CopyWith<T1, T2, T3, T4, T5, $Res> {
  factory $SampleData5CopyWith(SampleData5<T1, T2, T3, T4, T5> value,
          $Res Function(SampleData5<T1, T2, T3, T4, T5>) then) =
      _$SampleData5CopyWithImpl<T1, T2, T3, T4, T5, $Res,
          SampleData5<T1, T2, T3, T4, T5>>;
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4, T5 t5});
}

/// @nodoc
class _$SampleData5CopyWithImpl<T1, T2, T3, T4, T5, $Res,
        $Val extends SampleData5<T1, T2, T3, T4, T5>>
    implements $SampleData5CopyWith<T1, T2, T3, T4, T5, $Res> {
  _$SampleData5CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleData5
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
    Object? t5 = freezed,
  }) {
    return _then(_value.copyWith(
      t1: freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      t2: freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      t3: freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      t4: freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
      t5: freezed == t5
          ? _value.t5
          : t5 // ignore: cast_nullable_to_non_nullable
              as T5,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleData5ImplCopyWith<T1, T2, T3, T4, T5, $Res>
    implements $SampleData5CopyWith<T1, T2, T3, T4, T5, $Res> {
  factory _$$SampleData5ImplCopyWith(
          _$SampleData5Impl<T1, T2, T3, T4, T5> value,
          $Res Function(_$SampleData5Impl<T1, T2, T3, T4, T5>) then) =
      __$$SampleData5ImplCopyWithImpl<T1, T2, T3, T4, T5, $Res>;
  @override
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4, T5 t5});
}

/// @nodoc
class __$$SampleData5ImplCopyWithImpl<T1, T2, T3, T4, T5, $Res>
    extends _$SampleData5CopyWithImpl<T1, T2, T3, T4, T5, $Res,
        _$SampleData5Impl<T1, T2, T3, T4, T5>>
    implements _$$SampleData5ImplCopyWith<T1, T2, T3, T4, T5, $Res> {
  __$$SampleData5ImplCopyWithImpl(_$SampleData5Impl<T1, T2, T3, T4, T5> _value,
      $Res Function(_$SampleData5Impl<T1, T2, T3, T4, T5>) _then)
      : super(_value, _then);

  /// Create a copy of SampleData5
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
    Object? t5 = freezed,
  }) {
    return _then(_$SampleData5Impl<T1, T2, T3, T4, T5>(
      freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
      freezed == t5
          ? _value.t5
          : t5 // ignore: cast_nullable_to_non_nullable
              as T5,
    ));
  }
}

/// @nodoc

class _$SampleData5Impl<T1, T2, T3, T4, T5>
    implements _SampleData5<T1, T2, T3, T4, T5> {
  const _$SampleData5Impl(this.t1, this.t2, this.t3, this.t4, this.t5);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;
  @override
  final T5 t5;

  @override
  String toString() {
    return 'SampleData5<$T1, $T2, $T3, $T4, $T5>(t1: $t1, t2: $t2, t3: $t3, t4: $t4, t5: $t5)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData5Impl<T1, T2, T3, T4, T5> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4) &&
            const DeepCollectionEquality().equals(other.t5, t5));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4),
      const DeepCollectionEquality().hash(t5));

  /// Create a copy of SampleData5
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleData5ImplCopyWith<T1, T2, T3, T4, T5,
          _$SampleData5Impl<T1, T2, T3, T4, T5>>
      get copyWith => __$$SampleData5ImplCopyWithImpl<T1, T2, T3, T4, T5,
          _$SampleData5Impl<T1, T2, T3, T4, T5>>(this, _$identity);
}

abstract class _SampleData5<T1, T2, T3, T4, T5>
    implements SampleData5<T1, T2, T3, T4, T5> {
  const factory _SampleData5(
          final T1 t1, final T2 t2, final T3 t3, final T4 t4, final T5 t5) =
      _$SampleData5Impl<T1, T2, T3, T4, T5>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;
  @override
  T5 get t5;

  /// Create a copy of SampleData5
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleData5ImplCopyWith<T1, T2, T3, T4, T5,
          _$SampleData5Impl<T1, T2, T3, T4, T5>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SampleData6<T1, T2, T3, T4, T5, T6> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;
  T5 get t5 => throw _privateConstructorUsedError;
  T6 get t6 => throw _privateConstructorUsedError;

  /// Create a copy of SampleData6
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SampleData6CopyWith<T1, T2, T3, T4, T5, T6,
          SampleData6<T1, T2, T3, T4, T5, T6>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SampleData6CopyWith<T1, T2, T3, T4, T5, T6, $Res> {
  factory $SampleData6CopyWith(SampleData6<T1, T2, T3, T4, T5, T6> value,
          $Res Function(SampleData6<T1, T2, T3, T4, T5, T6>) then) =
      _$SampleData6CopyWithImpl<T1, T2, T3, T4, T5, T6, $Res,
          SampleData6<T1, T2, T3, T4, T5, T6>>;
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6});
}

/// @nodoc
class _$SampleData6CopyWithImpl<T1, T2, T3, T4, T5, T6, $Res,
        $Val extends SampleData6<T1, T2, T3, T4, T5, T6>>
    implements $SampleData6CopyWith<T1, T2, T3, T4, T5, T6, $Res> {
  _$SampleData6CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SampleData6
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
    Object? t5 = freezed,
    Object? t6 = freezed,
  }) {
    return _then(_value.copyWith(
      t1: freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      t2: freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      t3: freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      t4: freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
      t5: freezed == t5
          ? _value.t5
          : t5 // ignore: cast_nullable_to_non_nullable
              as T5,
      t6: freezed == t6
          ? _value.t6
          : t6 // ignore: cast_nullable_to_non_nullable
              as T6,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SampleData6ImplCopyWith<T1, T2, T3, T4, T5, T6, $Res>
    implements $SampleData6CopyWith<T1, T2, T3, T4, T5, T6, $Res> {
  factory _$$SampleData6ImplCopyWith(
          _$SampleData6Impl<T1, T2, T3, T4, T5, T6> value,
          $Res Function(_$SampleData6Impl<T1, T2, T3, T4, T5, T6>) then) =
      __$$SampleData6ImplCopyWithImpl<T1, T2, T3, T4, T5, T6, $Res>;
  @override
  @useResult
  $Res call({T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6});
}

/// @nodoc
class __$$SampleData6ImplCopyWithImpl<T1, T2, T3, T4, T5, T6, $Res>
    extends _$SampleData6CopyWithImpl<T1, T2, T3, T4, T5, T6, $Res,
        _$SampleData6Impl<T1, T2, T3, T4, T5, T6>>
    implements _$$SampleData6ImplCopyWith<T1, T2, T3, T4, T5, T6, $Res> {
  __$$SampleData6ImplCopyWithImpl(
      _$SampleData6Impl<T1, T2, T3, T4, T5, T6> _value,
      $Res Function(_$SampleData6Impl<T1, T2, T3, T4, T5, T6>) _then)
      : super(_value, _then);

  /// Create a copy of SampleData6
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t1 = freezed,
    Object? t2 = freezed,
    Object? t3 = freezed,
    Object? t4 = freezed,
    Object? t5 = freezed,
    Object? t6 = freezed,
  }) {
    return _then(_$SampleData6Impl<T1, T2, T3, T4, T5, T6>(
      freezed == t1
          ? _value.t1
          : t1 // ignore: cast_nullable_to_non_nullable
              as T1,
      freezed == t2
          ? _value.t2
          : t2 // ignore: cast_nullable_to_non_nullable
              as T2,
      freezed == t3
          ? _value.t3
          : t3 // ignore: cast_nullable_to_non_nullable
              as T3,
      freezed == t4
          ? _value.t4
          : t4 // ignore: cast_nullable_to_non_nullable
              as T4,
      freezed == t5
          ? _value.t5
          : t5 // ignore: cast_nullable_to_non_nullable
              as T5,
      freezed == t6
          ? _value.t6
          : t6 // ignore: cast_nullable_to_non_nullable
              as T6,
    ));
  }
}

/// @nodoc

class _$SampleData6Impl<T1, T2, T3, T4, T5, T6>
    implements _SampleData6<T1, T2, T3, T4, T5, T6> {
  const _$SampleData6Impl(this.t1, this.t2, this.t3, this.t4, this.t5, this.t6);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;
  @override
  final T5 t5;
  @override
  final T6 t6;

  @override
  String toString() {
    return 'SampleData6<$T1, $T2, $T3, $T4, $T5, $T6>(t1: $t1, t2: $t2, t3: $t3, t4: $t4, t5: $t5, t6: $t6)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData6Impl<T1, T2, T3, T4, T5, T6> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4) &&
            const DeepCollectionEquality().equals(other.t5, t5) &&
            const DeepCollectionEquality().equals(other.t6, t6));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4),
      const DeepCollectionEquality().hash(t5),
      const DeepCollectionEquality().hash(t6));

  /// Create a copy of SampleData6
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SampleData6ImplCopyWith<T1, T2, T3, T4, T5, T6,
          _$SampleData6Impl<T1, T2, T3, T4, T5, T6>>
      get copyWith => __$$SampleData6ImplCopyWithImpl<T1, T2, T3, T4, T5, T6,
          _$SampleData6Impl<T1, T2, T3, T4, T5, T6>>(this, _$identity);
}

abstract class _SampleData6<T1, T2, T3, T4, T5, T6>
    implements SampleData6<T1, T2, T3, T4, T5, T6> {
  const factory _SampleData6(final T1 t1, final T2 t2, final T3 t3, final T4 t4,
      final T5 t5, final T6 t6) = _$SampleData6Impl<T1, T2, T3, T4, T5, T6>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;
  @override
  T5 get t5;
  @override
  T6 get t6;

  /// Create a copy of SampleData6
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SampleData6ImplCopyWith<T1, T2, T3, T4, T5, T6,
          _$SampleData6Impl<T1, T2, T3, T4, T5, T6>>
      get copyWith => throw _privateConstructorUsedError;
}
