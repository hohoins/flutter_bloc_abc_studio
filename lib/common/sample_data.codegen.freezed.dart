// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sample_data.codegen.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SampleData2<T1, T2> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
}

/// @nodoc

class _$SampleData2Impl<T1, T2> implements _SampleData2<T1, T2> {
  const _$SampleData2Impl(this.t1, this.t2);

  @override
  final T1 t1;
  @override
  final T2 t2;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData2Impl<T1, T2> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2));
}

abstract class _SampleData2<T1, T2> implements SampleData2<T1, T2> {
  const factory _SampleData2(final T1 t1, final T2 t2) =
      _$SampleData2Impl<T1, T2>;

  @override
  T1 get t1;
  @override
  T2 get t2;
}

/// @nodoc
mixin _$SampleData3<T1, T2, T3> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
}

/// @nodoc

class _$SampleData3Impl<T1, T2, T3> implements _SampleData3<T1, T2, T3> {
  const _$SampleData3Impl(this.t1, this.t2, this.t3);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData3Impl<T1, T2, T3> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3));
}

abstract class _SampleData3<T1, T2, T3> implements SampleData3<T1, T2, T3> {
  const factory _SampleData3(final T1 t1, final T2 t2, final T3 t3) =
      _$SampleData3Impl<T1, T2, T3>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
}

/// @nodoc
mixin _$SampleData4<T1, T2, T3, T4> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;
}

/// @nodoc

class _$SampleData4Impl<T1, T2, T3, T4>
    implements _SampleData4<T1, T2, T3, T4> {
  const _$SampleData4Impl(this.t1, this.t2, this.t3, this.t4);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData4Impl<T1, T2, T3, T4> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4));
}

abstract class _SampleData4<T1, T2, T3, T4>
    implements SampleData4<T1, T2, T3, T4> {
  const factory _SampleData4(
          final T1 t1, final T2 t2, final T3 t3, final T4 t4) =
      _$SampleData4Impl<T1, T2, T3, T4>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;
}

/// @nodoc
mixin _$SampleData5<T1, T2, T3, T4, T5> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;
  T5 get t5 => throw _privateConstructorUsedError;
}

/// @nodoc

class _$SampleData5Impl<T1, T2, T3, T4, T5>
    implements _SampleData5<T1, T2, T3, T4, T5> {
  const _$SampleData5Impl(this.t1, this.t2, this.t3, this.t4, this.t5);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;
  @override
  final T5 t5;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData5Impl<T1, T2, T3, T4, T5> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4) &&
            const DeepCollectionEquality().equals(other.t5, t5));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4),
      const DeepCollectionEquality().hash(t5));
}

abstract class _SampleData5<T1, T2, T3, T4, T5>
    implements SampleData5<T1, T2, T3, T4, T5> {
  const factory _SampleData5(
          final T1 t1, final T2 t2, final T3 t3, final T4 t4, final T5 t5) =
      _$SampleData5Impl<T1, T2, T3, T4, T5>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;
  @override
  T5 get t5;
}

/// @nodoc
mixin _$SampleData6<T1, T2, T3, T4, T5, T6> {
  T1 get t1 => throw _privateConstructorUsedError;
  T2 get t2 => throw _privateConstructorUsedError;
  T3 get t3 => throw _privateConstructorUsedError;
  T4 get t4 => throw _privateConstructorUsedError;
  T5 get t5 => throw _privateConstructorUsedError;
  T6 get t6 => throw _privateConstructorUsedError;
}

/// @nodoc

class _$SampleData6Impl<T1, T2, T3, T4, T5, T6>
    implements _SampleData6<T1, T2, T3, T4, T5, T6> {
  const _$SampleData6Impl(this.t1, this.t2, this.t3, this.t4, this.t5, this.t6);

  @override
  final T1 t1;
  @override
  final T2 t2;
  @override
  final T3 t3;
  @override
  final T4 t4;
  @override
  final T5 t5;
  @override
  final T6 t6;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SampleData6Impl<T1, T2, T3, T4, T5, T6> &&
            const DeepCollectionEquality().equals(other.t1, t1) &&
            const DeepCollectionEquality().equals(other.t2, t2) &&
            const DeepCollectionEquality().equals(other.t3, t3) &&
            const DeepCollectionEquality().equals(other.t4, t4) &&
            const DeepCollectionEquality().equals(other.t5, t5) &&
            const DeepCollectionEquality().equals(other.t6, t6));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(t1),
      const DeepCollectionEquality().hash(t2),
      const DeepCollectionEquality().hash(t3),
      const DeepCollectionEquality().hash(t4),
      const DeepCollectionEquality().hash(t5),
      const DeepCollectionEquality().hash(t6));
}

abstract class _SampleData6<T1, T2, T3, T4, T5, T6>
    implements SampleData6<T1, T2, T3, T4, T5, T6> {
  const factory _SampleData6(final T1 t1, final T2 t2, final T3 t3, final T4 t4,
      final T5 t5, final T6 t6) = _$SampleData6Impl<T1, T2, T3, T4, T5, T6>;

  @override
  T1 get t1;
  @override
  T2 get t2;
  @override
  T3 get t3;
  @override
  T4 get t4;
  @override
  T5 get t5;
  @override
  T6 get t6;
}
